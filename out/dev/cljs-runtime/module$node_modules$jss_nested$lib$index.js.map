{
"version":3,
"file":"module$node_modules$jss_nested$lib$index.js",
"lineCount":5,
"mappings":"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",
"sources":["node_modules/jss-nested/lib/index.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$jss_nested$lib$index\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.default = jssNested;\n\nvar _warning = require('warning');\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar separatorRegExp = /\\s*,\\s*/g;\nvar parentRegExp = /&/g;\nvar refRegExp = /\\$([\\w-]+)/g;\n\n/**\n * Convert nested rules to separate, remove them from original styles.\n *\n * @param {Rule} rule\n * @api public\n */\nfunction jssNested() {\n  // Get a function to be used for $ref replacement.\n  function getReplaceRef(container) {\n    return function (match, key) {\n      var rule = container.getRule(key);\n      if (rule) return rule.selector;\n      (0, _warning2.default)(false, '[JSS] Could not find the referenced rule %s in %s.', key, container.options.meta || container);\n      return key;\n    };\n  }\n\n  var hasAnd = function hasAnd(str) {\n    return str.indexOf('&') !== -1;\n  };\n\n  function replaceParentRefs(nestedProp, parentProp) {\n    var parentSelectors = parentProp.split(separatorRegExp);\n    var nestedSelectors = nestedProp.split(separatorRegExp);\n\n    var result = '';\n\n    for (var i = 0; i < parentSelectors.length; i++) {\n      var parent = parentSelectors[i];\n\n      for (var j = 0; j < nestedSelectors.length; j++) {\n        var nested = nestedSelectors[j];\n        if (result) result += ', ';\n        // Replace all & by the parent or prefix & with the parent.\n        result += hasAnd(nested) ? nested.replace(parentRegExp, parent) : parent + ' ' + nested;\n      }\n    }\n\n    return result;\n  }\n\n  function getOptions(rule, container, options) {\n    // Options has been already created, now we only increase index.\n    if (options) return _extends({}, options, { index: options.index + 1 });\n\n    var nestingLevel = rule.options.nestingLevel;\n\n    nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;\n\n    return _extends({}, rule.options, {\n      nestingLevel: nestingLevel,\n      index: container.indexOf(rule) + 1\n    });\n  }\n\n  function onProcessStyle(style, rule) {\n    if (rule.type !== 'style') return style;\n    var container = rule.options.parent;\n    var options = void 0;\n    var replaceRef = void 0;\n    for (var prop in style) {\n      var isNested = hasAnd(prop);\n      var isNestedConditional = prop[0] === '@';\n\n      if (!isNested && !isNestedConditional) continue;\n\n      options = getOptions(rule, container, options);\n\n      if (isNested) {\n        var selector = replaceParentRefs(prop, rule.selector\n        // Lazily create the ref replacer function just once for\n        // all nested rules within the sheet.\n        );if (!replaceRef) replaceRef = getReplaceRef(container\n        // Replace all $refs.\n        );selector = selector.replace(refRegExp, replaceRef);\n\n        container.addRule(selector, style[prop], _extends({}, options, { selector: selector }));\n      } else if (isNestedConditional) {\n        container\n        // Place conditional right after the parent rule to ensure right ordering.\n        .addRule(prop, null, options).addRule(rule.key, style[prop], { selector: rule.selector });\n      }\n\n      delete style[prop];\n    }\n\n    return style;\n  }\n\n  return { onProcessStyle: onProcessStyle };\n}\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","Object","defineProperty","value","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","default","jssNested","getReplaceRef","container","match","rule","getRule","selector","_warning2","options","meta","onProcessStyle","style","type","parent","replaceRef","prop","isNested","indexOf","isNestedConditional","index","nestingLevel","undefined","parentSelectors","split","separatorRegExp","nestedSelectors","nestedProp","result","j","nested","replace","parentRegExp","refRegExp","addRule","_warning","__esModule"]
}
